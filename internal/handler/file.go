// Code generated by https://github.com/go-dev-frame/sponge

package handler

import (
	"context"
	"encoding/base64"
	"fmt"
	"github.com/go-dev-frame/sponge/pkg/errcode"
	"github.com/go-dev-frame/sponge/pkg/gin/middleware"
	"go.uber.org/zap"
	"io"
	"mime/multipart"
	"os"
	"strings"

	//"github.com/go-dev-frame/sponge/pkg/gin/middleware"

	schoolV1 "school/api/school/v1"
)

var _ schoolV1.FileLogicer = (*fileHandler)(nil)

type fileHandler struct {
	// example:
	// 	fileDao dao.FileDao
}

// NewFileHandler create a handler
func NewFileHandler() schoolV1.FileLogicer {
	return &fileHandler{
		// example:
		// 	fileDao: dao.NewFileDao(
		// 		database.GetDB(),
		// 		cache.NewFileCache(database.GetCacheType()),
		// 	),
	}
}

// CreateFile ......
func (h *fileHandler) CreateFile(ctx context.Context, req *schoolV1.UploadFileRequest) (*schoolV1.UploadFileResponse, error) {
	c, _ := middleware.AdaptCtx(ctx)
	fh, err := c.FormFile("file")
	if err != nil {
		return nil, err
	}
	filenameBytes := make([]byte, base64.StdEncoding.EncodedLen(len(fh.Filename)))
	base64.StdEncoding.Encode(filenameBytes, []byte(fh.Filename))
	targetFile, err := os.OpenFile("uploads/"+strings.TrimRight(string(filenameBytes), "\x00"), os.O_CREATE|os.O_WRONLY, 0666)
	if err != nil {
		zap.Error(err)
		return nil, err
	}
	defer func(targetFile *os.File) {
		err := targetFile.Close()
		if err != nil {
			zap.Error(err)

		}
	}(targetFile)
	file, err := fh.Open()
	defer func(file multipart.File) {
		err := file.Close()
		if err != nil {
		}
	}(file)
	_, err = io.Copy(targetFile, file)
	if err != nil {
		zap.Error(err)
		return nil, err
	}
	fileinfo, err := os.Stat(targetFile.Name())
	if err != nil {
		zap.Error(err)

		return nil, err
	}
	return &schoolV1.UploadFileResponse{
		FileId:   fileinfo.Name(),
		FileName: fh.Filename,
		FileSize: fileinfo.Size(),
	}, nil
}

// DownloadFile ......
func (h *fileHandler) DownloadFile(ctx context.Context, req *schoolV1.DownloadFileRequest) (*schoolV1.DownloadFileResponse, error) {
	c, _ := middleware.AdaptCtx(ctx)
	filename := make([]byte, base64.StdEncoding.EncodedLen(len(req.FileId)))
	_, err := base64.StdEncoding.Decode(filename, []byte(req.FileId))
	if err != nil {
		return nil, err
	}
	c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=%q", strings.TrimRight(string(filename), "\x00")))
	c.File("uploads/" + req.FileId)
	return &schoolV1.DownloadFileResponse{}, errcode.SkipResponse
}
